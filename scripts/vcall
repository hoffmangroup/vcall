#!/usr/bin/env python
from __future__ import division, print_function

"""
vcall: recursively run version control commands

version control systems supported: CVS, Subversion, Mercurial
commands supported: status, update

cvs -n update has a bug where it will print things like

  cvs update: New directory `search_spectrum_out' -- ignored

for any directory that has been deleted in the repository. For more
info Google [cvs-info "new directory" ignored]. I can't figure out a
way to suppress this.
"""

__version__ = "$Revision$"

# Copyright 2008, 2013 Michael M. Hoffman <hoffman+software@ebi.ac.uk>

from os import walk
from os.path import relpath
import re
import sys

from optbuild import (OptionBuilder, OptionBuilder_ShortOptWithSpace,
                      ReturncodeError)

HG_PROG = OptionBuilder("hg")
SVN_PROG = OptionBuilder("svn")
CVS_PROG = OptionBuilder_ShortOptWithSpace("cvs")

CVS_KWARGS_DEFAULT = dict(q=True)  # quiet


def make_args(command, subcommand, dirname):
    if subcommand is not None:
        return [command, subcommand, dirname]
    else:
        return [command, dirname]

re_cvs_new_directory_ignored = re.compile(r"^cvs update: New directory `.*'"
                                          " -- ignored$")


def try_prog(prog, funcname, dirname, *args, **kwargs):
    try:
        return getattr(prog, funcname)(*args, **kwargs)
    except ReturncodeError:
        msg = "Error detected from %s in %s; repeating" % (program, dirname)
        print(msg, file=sys.stderr)
        prog(*args, **kwargs)


def run_cvs(command, dirname):
    subcommand = None
    kwargs = CVS_KWARGS_DEFAULT.copy()

    if command == "status":
        command = "update"
        kwargs["n"] = True  # don't do anything on disk

    if command == "update":
        subcommand = "-dP"

    ## relpath avoids "absolute pathname ... illegal for server" error
    args = make_args(command, subcommand, relpath(dirname))

    output, error = try_prog(CVS_PROG, "getoutput_error", *args, **kwargs)

    if output:
        print(output, end="")
    if error:
        error_lines = error.splitlines()
        for error_line in error_lines:
            if not re_cvs_new_directory_ignored.match(error_line):
                print(error_line, file=sys.stderr)

re_svn_status_against = re.compile(r"^Status against revision:")


def run_svn(command, dirname):
    subcommand = None
    if command == "status":
        subcommand = "-u"

    args = make_args(command, subcommand, dirname)

    output = try_prog(SVN_PROG, "getoutput", *args)

    if output:
        output_lines = output.splitlines()
        for output_line in output_lines:
            if not re_svn_status_against.match(output_line):
                print(output_line, file=sys.stderr)


def run_hg(command, dirname):
    kwargs = dict(cwd=dirname)

    if command == "status":
        command = "summary"
        kwargs["remote"] = True
    elif command == "update":
        command = "pull"

    HG_PROG(command, **kwargs)


RUNNERS = {".hg": run_hg,
           ".svn": run_svn,
           "CVS": run_cvs}


def vcall(command="status", *dirnames):
    if not dirnames:
        dirnames = ["."]

    if command.startswith("st"):
        command = "status"

    for dirname in dirnames:
        for branch_dirname, child_dirnames, child_filenames in walk(dirname):
            for signature_dirname, runner in RUNNERS.iteritems():
                # check for signature of any version control system
                if signature_dirname in child_dirnames:
                    runner(command, branch_dirname)
                    del child_dirnames[:]
                    break


def parse_options(args):
    from optparse import OptionParser

    usage = "%prog COMMAND [PATH...] [OPTION]..."
    version = "%%prog %s" % __version__
    parser = OptionParser(usage=usage, version=version)

    options, args = parser.parse_args(args)

    return options, args


def main(args=sys.argv[1:]):
    options, args = parse_options(args)

    return vcall(*args)

if __name__ == "__main__":
    sys.exit(main())
