#!/usr/bin/env python

"""vcall: recursively run version control commands

Run version control commands in multiple subdirectories.
COMMAND is one of: status, update, upgrade.
Version control systems supported: CVS, Subversion, Mercurial.
"""

from __future__ import division, print_function

__version__ = "$Revision$"

# Copyright 2008, 2013 Michael M. Hoffman <hoffman+software@ebi.ac.uk>

from os import walk
import re
import sys

from optbuild import (Cwd, OptionBuilder, OptionBuilder_LongOptWithSpace,
                      OptionBuilder_ShortOptWithSpace, ReturncodeError)

HG_PROG = OptionBuilder_LongOptWithSpace("hg")
SVN_PROG = OptionBuilder("svn")
CVS_PROG = OptionBuilder_ShortOptWithSpace("cvs")

CVS_KWARGS_DEFAULT = dict(q=True)  # quiet


def make_args(command, subcommand, dirname):
    if subcommand is not None:
        return [command, subcommand, dirname]
    else:
        return [command, dirname]


def try_prog(prog, funcname, dirname, *args, **kwargs):
    try:
        return getattr(prog, funcname)(*args, **kwargs)
    except ReturncodeError:
        msg = "Error detected from %s in %s; repeating" % (prog, dirname)
        print(msg, file=sys.stderr)
        prog(*args, **kwargs)


def output_lines(output):
    if output:
        return output.splitlines()

    return []


def print_except(output, regex, dirname=None):
    if dirname:
        prefix = "%s:" % dirname
    else:
        prefix = ""

    for line in output_lines(output):
        if not regex.match(line):
            print(prefix, line, file=sys.stderr)


re_cvs_new_directory_ignored = re.compile(r"^cvs update: New directory `.*'"
                                          " -- ignored$")


def run_cvs(command, dirname):
    """
    cvs -n update has a bug where it will print things like

      cvs update: New directory `search_spectrum_out' -- ignored

    for any directory that has been deleted in the repository. For more
    info Google [cvs-info "new directory" ignored]. I can't figure out a
    way to suppress this, except to actually delete things locally.
    """
    subcommand = None
    kwargs = CVS_KWARGS_DEFAULT.copy()

    if command == "upgrade":
        return

    if command == "status":
        command = "update"
        kwargs["n"] = True  # don't do anything on disk

    if command == "update":
        subcommand = "-dP"

    ## relpath avoids "absolute pathname ... illegal for server" error
    args = make_args(command, subcommand, ".")

    output, error = try_prog(CVS_PROG, "getoutput_error", dirname,
                             Cwd(dirname), *args, **kwargs)

    if output:
        print(output, end="")

    print_except(error, re_cvs_new_directory_ignored)


re_svn_status_against = re.compile(r"^Status against revision:")


def run_svn(command, dirname):
    subcommand = None
    if command == "status":
        subcommand = "-u"

    args = make_args(command, subcommand, dirname)

    output = try_prog(SVN_PROG, "getoutput", dirname, *args)
    print_except(output, re_svn_status_against)


re_hg_quiet_summary = re.compile(r"^(?!(?:commit|update|remote): )"
                                 "|(?:commit: \(clean\)|update: \(current\)"
                                 "|remote: \(synced\))$")
re_hg_0_updates = re.compile(r"^0 files updated, 0 files merged,"
                             " 0 files removed, 0 files unresolved$")


def run_hg(command, dirname):
    kwargs = dict(cwd=dirname)

    if command == "status":
        args = ["summary", "--remote"]
    elif command == "upgrade":
        return
    elif command == "update":
        try:
            HG_PROG("pull", quiet=True, **kwargs)
        except ReturncodeError, err:
            ## exit status 1 when there is nothing new incoming
            if err.returncode == 1:
                pass

        output = try_prog(HG_PROG, "getoutput", dirname, "update", cwd=dirname)
        print_except(output, re_hg_0_updates, dirname)

        return
    else:
        args = [command]

    output = try_prog(HG_PROG, "getoutput", dirname, *args, **kwargs)
    print_except(output, re_hg_quiet_summary, dirname)


RUNNERS = {".hg": run_hg,
           ".svn": run_svn,
           "CVS": run_cvs}


def _vcall(command, dirnames, keep_going):
    for dirname in dirnames:
        for branch_dirname, child_dirnames, child_filenames in walk(dirname):
            for signature_dirname, runner in RUNNERS.iteritems():
                # check for signature of any version control system
                if signature_dirname in child_dirnames:
                    try:
                        runner(command, branch_dirname)
                    except ReturncodeError:
                        pass  # already reported earlier
                    del child_dirnames[:]
                    break


def vcall(command="status", dirnames=[], keep_going=False):
    if not dirnames:
        dirnames = ["."]

    if command.startswith("st"):
        command = "status"
    elif command.startswith("upg"):
        command = "upgrade"
    elif command.startswith("up"):
        command = "update"

    return _vcall(command, dirnames, keep_going)


def parse_options(args):
    from optparse import OptionParser

    usage = "%prog [OPTION...] COMMAND [DIR...]"
    version = "%%prog %s" % __version__
    doclines = __doc__.splitlines()
    long_description = "\n".join(doclines[2:])

    # XXX: should switch to argparse to get RawDescriptionHelpFormatter
    parser = OptionParser(usage=usage, version=version,
                          description=long_description)
    parser.add_option("--keep-going", "-k", action="store_true",
                      help="Continue after failure running version control"
                      " system in one directory.")

    options, args = parser.parse_args(args)

    if len(args) < 1:
        parser.error("incorrect number of arguments")

    return options, args


def main(args=sys.argv[1:]):
    options, args = parse_options(args)

    return vcall(args[0], args[1:], options.keep_going)

if __name__ == "__main__":
    sys.exit(main())
