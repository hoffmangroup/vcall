#!/usr/bin/env python
from __future__ import division, print_function

"""
vcall: recursively run version control commands

version control systems supported: CVS, Subversion, Mercurial
commands supported: status, update

cvs -n update has a bug where it will print things like

  cvs update: New directory `search_spectrum_out' -- ignored

for any directory that has been deleted in the repository. For more
info Google [cvs-info "new directory" ignored]. I can't figure out a
way to suppress this.
"""

__version__ = "$Revision$"

# Copyright 2008, 2013 Michael M. Hoffman <hoffman+software@ebi.ac.uk>

from os import walk
from os.path import relpath
import re
import sys

from optbuild import (OptionBuilder, OptionBuilder_LongOptWithSpace,
                      OptionBuilder_ShortOptWithSpace, ReturncodeError)

HG_PROG = OptionBuilder_LongOptWithSpace("hg")
SVN_PROG = OptionBuilder("svn")
CVS_PROG = OptionBuilder_ShortOptWithSpace("cvs")

CVS_KWARGS_DEFAULT = dict(q=True)  # quiet


def make_args(command, subcommand, dirname):
    if subcommand is not None:
        return [command, subcommand, dirname]
    else:
        return [command, dirname]


def try_prog(prog, funcname, *args, **kwargs):
    try:
        return getattr(prog, funcname)(*args, **kwargs)
    except ReturncodeError:
        # XXX: does str(prog) actually return the program name?

        # XXX: would be nice if this actually printed the command name
        # instead; can be done with optbuild

        msg = "Error detected from %s; repeating" % prog
        print(msg, file=sys.stderr)
        prog(*args, **kwargs)


def output_lines(output):
    if output:
        return output.splitlines()

    return []


def print_except(output, regex, dirname=None):
    if dirname:
        prefix = "%s:" % dirname
    else:
        prefix = ""

    for line in output_lines(output):
        if not regex.match(line):
            print(prefix, line, file=sys.stderr)


re_cvs_new_directory_ignored = re.compile(r"^cvs update: New directory `.*'"
                                          " -- ignored$")


def run_cvs(command, dirname):
    subcommand = None
    kwargs = CVS_KWARGS_DEFAULT.copy()

    if command == "status":
        command = "update"
        kwargs["n"] = True  # don't do anything on disk

    if command == "update":
        subcommand = "-dP"

    ## relpath avoids "absolute pathname ... illegal for server" error
    args = make_args(command, subcommand, relpath(dirname))

    output, error = try_prog(CVS_PROG, "getoutput_error", *args, **kwargs)

    if output:
        print(output, end="")

    print_except(error, re_cvs_new_directory_ignored)


re_svn_status_against = re.compile(r"^Status against revision:")


def run_svn(command, dirname):
    subcommand = None
    if command == "status":
        subcommand = "-u"

    args = make_args(command, subcommand, dirname)

    output = try_prog(SVN_PROG, "getoutput", *args)
    print_except(output, re_svn_status_against)


re_hg_parent_branch = re.compile(r"^(?:parent|branch): ")
re_hg_0_updates = re.compile(r"^0 files updated, 0 files merged, 0 files removed, 0 files unresolved$")


def run_hg(command, dirname):
    kwargs = dict(cwd=dirname, quiet=True)

    if command == "status":
        args = ["summary", "--remote"]
    elif command == "update":
        try:
            HG_PROG("pull", **kwargs)
        except ReturncodeError, err:
            if err.returncode == 1:
                pass

        # don't want quiet
        output = try_prog(HG_PROG, "getoutput", "update", cwd=dirname)
        print_except(output, re_hg_0_updates, dirname)

        return
    else:
        args = [command]

    output = try_prog(HG_PROG, "getoutput", *args, **kwargs)
    print_except(output, re_hg_parent_branch, dirname)


RUNNERS = {".hg": run_hg,
           ".svn": run_svn,
           "CVS": run_cvs}


def vcall(command="status", *dirnames):
    if not dirnames:
        dirnames = ["."]

    if command.startswith("st"):
        command = "status"
    elif command.startswith("up"):
        command = "update"

    for dirname in dirnames:
        for branch_dirname, child_dirnames, child_filenames in walk(dirname):
            for signature_dirname, runner in RUNNERS.iteritems():
                # check for signature of any version control system
                if signature_dirname in child_dirnames:
                    runner(command, branch_dirname)
                    del child_dirnames[:]
                    break


def parse_options(args):
    from optparse import OptionParser

    usage = "%prog COMMAND [PATH...] [OPTION]..."
    version = "%%prog %s" % __version__
    parser = OptionParser(usage=usage, version=version)

    options, args = parser.parse_args(args)

    return options, args


def main(args=sys.argv[1:]):
    options, args = parse_options(args)

    return vcall(*args)

if __name__ == "__main__":
    sys.exit(main())
